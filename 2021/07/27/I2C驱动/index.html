<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>I2C驱动 | Hexo</title>
  <meta name="description" content="1. I2C模块框架1.1. I2C体系基于linux4.19内核 1.1.1. I2C核心I2C 核心提供了I2C 总线驱动和设备驱动的注册、注销方法，I2C 通信方法（即“algorithm”）上层的、与具体适配器无关的代码以及探测设备、检测设备地址的上层代码等。 1.1.2. I2C总线驱动I2C 总线驱动是对I2C 硬件体系结构中适配器端的实现，适配器可由CPU 控制，甚至可以直接集成在C">
<meta property="og:type" content="article">
<meta property="og:title" content="I2C驱动">
<meta property="og:url" content="http://lskin.github.io/2021/07/27/I2C%E9%A9%B1%E5%8A%A8/index.html">
<meta property="og:site_name">
<meta property="og:description" content="1. I2C模块框架1.1. I2C体系基于linux4.19内核 1.1.1. I2C核心I2C 核心提供了I2C 总线驱动和设备驱动的注册、注销方法，I2C 通信方法（即“algorithm”）上层的、与具体适配器无关的代码以及探测设备、检测设备地址的上层代码等。 1.1.2. I2C总线驱动I2C 总线驱动是对I2C 硬件体系结构中适配器端的实现，适配器可由CPU 控制，甚至可以直接集成在C">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://lskin.github.io/2021/07/27/I2C%E9%A9%B1%E5%8A%A8/i2c%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.png">
<meta property="og:image" content="http://lskin.github.io/2021/07/27/I2C%E9%A9%B1%E5%8A%A8/i2c%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="article:published_time" content="2021-07-27T14:47:23.000Z">
<meta property="article:modified_time" content="2021-08-31T13:57:30.784Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lskin.github.io/2021/07/27/I2C%E9%A9%B1%E5%8A%A8/i2c%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://lskin.github.io/2021/07/27/I2C%E9%A9%B1%E5%8A%A8/index.html">
  
    <link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://lskin.top" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg#%E5%A4%B4%E5%83%8F" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">新坚</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">开发者</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> 珠海</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/lskin" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      

    
      

    
      
    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2021/07/27/V4L2%E9%A9%B1%E5%8A%A8/" class="title">V4L2驱动</a>
              </p>
              <p class="item-date">
                <time datetime="2021-07-27T15:13:06.000Z" itemprop="datePublished">2021-07-27</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2021/07/27/I2C%E9%A9%B1%E5%8A%A8/" class="title">I2C驱动</a>
              </p>
              <p class="item-date">
                <time datetime="2021-07-27T14:47:23.000Z" itemprop="datePublished">2021-07-27</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-I2C驱动" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      I2C驱动
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/07/27/I2C%E9%A9%B1%E5%8A%A8/" class="article-date">
	  <time datetime="2021-07-27T14:47:23.000Z" itemprop="datePublished">2021-07-27</time>
	</a>
</span>
        
        

        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/07/27/I2C%E9%A9%B1%E5%8A%A8/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="1-I2C模块框架"><a href="#1-I2C模块框架" class="headerlink" title="1. I2C模块框架"></a><strong>1.</strong> I2C模块框架</h1><h2 id="1-1-I2C体系"><a href="#1-1-I2C体系" class="headerlink" title="1.1. I2C体系"></a><strong>1.1.</strong> I2C体系</h2><p>基于linux4.19内核</p>
<h3 id="1-1-1-I2C核心"><a href="#1-1-1-I2C核心" class="headerlink" title="1.1.1. I2C核心"></a>1.1.1. I2C核心</h3><p>I2C 核心提供了I2C 总线驱动和设备驱动的注册、注销方法，I2C 通信方法（即“algorithm”）上层的、与具体适配器无关的代码以及探测设备、检测设备地址的上层代码等。</p>
<h3 id="1-1-2-I2C总线驱动"><a href="#1-1-2-I2C总线驱动" class="headerlink" title="1.1.2. I2C总线驱动"></a>1.1.2. I2C总线驱动</h3><p>I2C 总线驱动是对I2C 硬件体系结构中适配器端的实现，适配器可由CPU 控制，甚至可以直接集成在CPU 内部。主要包含了I2C 适配器数据结构i2c_adapter、I2C 适配器的algorithm 数据结构i2c_algorithm 和控制I2C 适配器产生通信信号的函数。</p>
<p>经由I2C 总线驱动的代码，我们可以控制I2C 适配器以主控方式产生开始位、停止位、读写周期，以及以从设备方式被读写、产生ACK 等。</p>
<h3 id="1-1-3-I2C设备驱动"><a href="#1-1-3-I2C设备驱动" class="headerlink" title="1.1.3. I2C设备驱动"></a>1.1.3. I2C设备驱动</h3><p>I2C 设备驱动（也称为客户驱动）是对I2C 硬件体系结构中设备端的实现，设备一般挂接在受CPU 控制的I2C 适配器上，通过I2C 适配器与CPU 交换数据。I2C 设备驱动主要包含了数据结构i2c_driver 和i2c_client，我们需要根据具体设备实现其中的成员函数。</p>
<p><img src="/2021/07/27/I2C%E9%A9%B1%E5%8A%A8/i2c%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.png"></p>
<p>​                                                    图2.1 linux i2c体系结构</p>
<h2 id="1-2-文件结构"><a href="#1-2-文件结构" class="headerlink" title="1.2. 文件结构"></a><strong>1.2.</strong> 文件结构</h2><h3 id="1-2-1-i2c-core-base-c"><a href="#1-2-1-i2c-core-base-c" class="headerlink" title="1.2.1. i2c-core-base.c"></a>1.2.1. i2c-core-base.c</h3><p>这个文件实现了I2C核心的功能以及/proc/bus/i2c接口。</p>
<h3 id="1-2-2-i2c-core-acpi-c"><a href="#1-2-2-i2c-core-acpi-c" class="headerlink" title="1.2.2. i2c-core-acpi.c"></a>1.2.2. i2c-core-acpi.c</h3><p>电源管理相关接口</p>
<h3 id="1-2-3-i2c-core-of-c"><a href="#1-2-3-i2c-core-of-c" class="headerlink" title="1.2.3. i2c-core-of.c"></a>1.2.3. i2c-core-of.c</h3><p>设备数注册相关接口</p>
<h3 id="1-2-4-i2c-core-slave-c"><a href="#1-2-4-i2c-core-slave-c" class="headerlink" title="1.2.4. i2c-core-slave.c"></a>1.2.4. i2c-core-slave.c</h3><p>从机操作接口</p>
<h3 id="1-2-5-i2c-dev-c"><a href="#1-2-5-i2c-dev-c" class="headerlink" title="1.2.5. i2c-dev.c"></a>1.2.5. i2c-dev.c</h3><p>这个文件实现了I2C适配器设备文件的功能，每一个I2C适配器都被分配一个设备。通过适配器访设备时的主设备号都为89，次设备号为0-255。I2c-dev.c并没有针对特定的设备而设计，只是提供了通用的read(),write(),和ioctl()等接口，应用层可以借用这些接口访问挂接在适配器上的I2C设备的存储空间或寄存器，并控制I2C设备的工作方式。</p>
<h3 id="1-2-6-busses文件夹"><a href="#1-2-6-busses文件夹" class="headerlink" title="1.2.6. busses文件夹"></a>1.2.6. busses文件夹</h3><p>该文件夹这个文件中包含了一些I2C总线的驱动，如针对S3C2410，S3C2440，S3C6410等处理器的I2C控制器驱动为i2c-s3c2410.c.</p>
<h3 id="1-2-7-algos文件夹"><a href="#1-2-7-algos文件夹" class="headerlink" title="1.2.7. algos文件夹"></a>1.2.7. algos文件夹</h3><p>该文件夹实现了一些I2C总线适配器的algorithm.</p>
<h3 id="1-2-8-muxes文件夹"><a href="#1-2-8-muxes文件夹" class="headerlink" title="1.2.8. muxes文件夹"></a>1.2.8. muxes文件夹</h3><p>该文件夹是一些额外的复用功能，很少用到。</p>
<h2 id="1-3-重要的结构体"><a href="#1-3-重要的结构体" class="headerlink" title="1.3. 重要的结构体"></a><strong>1.3.</strong> 重要的结构体</h2><h3 id="1-3-1-i2c-driver-结构体"><a href="#1-3-1-i2c-driver-结构体" class="headerlink" title="1.3.1. i2c_driver 结构体"></a>1.3.1. i2c_driver 结构体</h3><p>该结构体代表了设备驱动程序，与i2c_client是一对多关系,即一个驱动可以对上多个设备，根据name进行匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_driver &#123;</span><br><span class="line">	unsigned int class;//注册了那种设备</span><br><span class="line">	int (*probe)(struct i2c_client *, const struct i2c_device_id *);//即将弃用</span><br><span class="line">	int (*remove)(struct i2c_client *);//接触设备绑定</span><br><span class="line">	int (*probe_new)(struct i2c_client *);//新接口回调</span><br><span class="line">	void (*shutdown)(struct i2c_client *);//关闭回调</span><br><span class="line">	void (*alert)(struct i2c_client *, unsigned int data);//smbus警报协议</span><br><span class="line">	int (*command)(struct i2c_client *client, unsigned int cmd, void*arg);//命令列表</span><br><span class="line">	struct device_driver driver;/* 设备驱动信息 */</span><br><span class="line">	const struct i2c_device_id *id_table;//该驱动所支持的设备ID表</span><br><span class="line">	int (*detect)(struct i2c_client *, struct i2c_board_info *);//进行设备检测</span><br><span class="line">	const unsigned short *address_list;//用于检测</span><br><span class="line">	struct list_head clients;//仅供i2c核心使用</span><br><span class="line">	bool disable_i2c_core_irq_mapping;//是否进行irq映射</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-i2c-client-结构体"><a href="#1-3-2-i2c-client-结构体" class="headerlink" title="1.3.2. i2c_client 结构体"></a>1.3.2. i2c_client 结构体</h3><p>该结构体定义了挂载在I2C总线下的slave设备,一个结构体对象代表一个slave设备。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_client &#123;</span><br><span class="line">    unsigned short flags；//标志  </span><br><span class="line">    unsigned short addr; //芯片地址 </span><br><span class="line">    char name[I2C_NAME_SIZE];//设备名称 </span><br><span class="line">    struct i2c_adapter *adapter;//依附的</span><br><span class="line">    i2c_adapter struct device dev;//从机的驱动程序模型设备节点  </span><br><span class="line">    int irq;//表示此设备生成的irq(如果有)  </span><br><span class="line">    struct list_head detected;//i2c驱动程序的成员</span><br><span class="line">#if IS_ENABLED(CONFIG_I2C_SLAVE)	</span><br><span class="line">	i2c_slave_cb_t slave_cb;	/* callback for slave mode	*/</span><br><span class="line">#endif </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-i2c-adapter-结构体"><a href="#1-3-3-i2c-adapter-结构体" class="headerlink" title="1.3.3. i2c_adapter 结构体"></a>1.3.3. i2c_adapter 结构体</h3><p>该结构体定义了一个物理层次的I2C总线。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_adapter &#123;</span><br><span class="line">	struct module *owner;//所属模块</span><br><span class="line">	//algorithm的类型，定义于i2c-id.h,</span><br><span class="line">	unsigned int class;</span><br><span class="line">	struct i2c_algorithm *algo;   /* 总线通信方法结构体指针	*/</span><br><span class="line">	void *algo_data;//algorithm数据</span><br><span class="line"></span><br><span class="line">	/* data fields that are valid for all devices	*/</span><br><span class="line">	const struct i2c_lock_operations *lock_ops;</span><br><span class="line">	struct rt_mutex bus_lock;</span><br><span class="line">	struct rt_mutex mux_lock;</span><br><span class="line"></span><br><span class="line">	int timeout; /* 定义超时时间 */</span><br><span class="line">	int retries;  /* 重试次数 */</span><br><span class="line">	struct device dev;		/*  adapter 设备 */</span><br><span class="line"></span><br><span class="line">	int nr; /* 总线号 */</span><br><span class="line">	struct completion dev_released;</span><br><span class="line"></span><br><span class="line">	struct mutex userspace_clients_lock;</span><br><span class="line">	struct list_head userspace_clients;</span><br><span class="line"></span><br><span class="line">	struct i2c_bus_recovery_info *bus_recovery_info;</span><br><span class="line">	const struct i2c_adapter_quirks *quirks;</span><br><span class="line"></span><br><span class="line">	struct irq_domain *host_notify_domain;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-4-i2c-algorithm-结构体"><a href="#1-3-4-i2c-algorithm-结构体" class="headerlink" title="1.3.4. i2c_algorithm 结构体"></a>1.3.4. i2c_algorithm 结构体</h3><p>该I2C主设备传输数据的算法。 其中提供了关键的函数master_xfer()用于产生i2c访问周期需要的信号，以i2c_msg为单位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_algorithm &#123;</span><br><span class="line">		/* </span><br><span class="line">         *一般都使用 master_xfer() 算法</span><br><span class="line">        */</span><br><span class="line">	int (*master_xfer)(struct i2c_adapter *adap,struct i2c_msg *msgs, </span><br><span class="line">	                   int num);//I2C传输函数指针</span><br><span class="line">	int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr, </span><br><span class="line">	                   unsigned short flags, char read_write,</span><br><span class="line">	                   u8 command, int size, union i2c_smbus_data * data);//smbus传输函数指针</span><br><span class="line"> 	u32 (*functionality) (struct i2c_adapter *);//返回此算法支持的功能标志</span><br><span class="line"></span><br><span class="line">#if IS_ENABLED(CONFIG_I2C_SLAVE)</span><br><span class="line">	int (*reg_slave)(struct i2c_client *client);//将客户端注册到此设配置器的I2C从模式</span><br><span class="line">	int (*unreg_slave)(struct i2c_client *client);</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-5-i2c-msg-结构体"><a href="#1-3-5-i2c-msg-结构体" class="headerlink" title="1.3.5. i2c_msg 结构体"></a>1.3.5. i2c_msg 结构体</h3><p>I2C_M_IGNORE_NAK：设置这个标志意味当前i2c_msg忽略I2C器件的ack和nack信号。</p>
<p>I2C_M_NOSTART：设置这个标志意味当前i2c_msg不发送start信号。</p>
<p>​        1）msgs序列第一个数据必须是地址，同时必须不定义这个标志位</p>
<p>​        2）在进行读数据，要从写操作转变为读操作时，会发重复start信号和器件地址时，必须不定义这个标志位</p>
<p>​        3）其它情况下一的i2c_msg必须定义这个标志</p>
<p>​        4）同时1和2总结下来就是发器件地址（注意，是器件地址，不是像EEPROM那样的EEPROM地址，这个地址是当数据发的）时会不设置I2C_M_NOSTART, 发数据时就设置I2C_M_NOSTART这个标志。</p>
<p>I2C_M_NO_RD_ACK：这个标识表示在正行读操作时不去ACK，我不知道其它芯片如果，如果是AT24C04则一定不能设这个标志位了。</p>
<p>（下面三个标志为均为bit_doAddress函数使用，结合上面的说明，也就是这时I2C_M_NOSTART一定没有设置。）</p>
<p>I2C_M_RD：表示这是一个读操作，默认是把相应的位置1</p>
<p>I2C_M_REV_DIR_ADDR：表示把读写标志位反转，也就是读是把相应位置0</p>
<p>I2C_M_TEN：表示这个器件的器件地址是10Bit的。一定要搞清，这是器件地址，不是指EEPROM的ROM地址。</p>
<p>24C02等芯片真正的器件地址只有4位永远有效（0xA)，低4位用来放其它东西了（根据容量有可能是器件地址的低3位，或ROM地址的高3位）。也是说，无论什么容量，这类器件的地址只是器件地址我们只选7位模式（内核只区分10位模式和其它模式）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_msg &#123;</span><br><span class="line">    __u16 addr;	/* 从设备地址 */</span><br><span class="line">    __u16 flags;	/* 设备标示 */	</span><br><span class="line">    #define I2C_M_TEN 0x10	 /* 这个使用10-bit地址 */</span><br><span class="line">    #define I2C_M_RD	0x01</span><br><span class="line">    #define I2C_M_NOSTART	0x4000</span><br><span class="line">    #define I2C_M_REV_DIR_ADDR	0x2000</span><br><span class="line">    #define I2C_M_IGNORE_NAK	0x1000</span><br><span class="line">    #define I2C_M_NO_RD_ACK		0x0800 </span><br><span class="line">    __u16 len;		/* msg 长度 */ </span><br><span class="line">    __u8 *buf;		/* msg数据指针	*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-6-i2c-board-info-结构体"><a href="#1-3-6-i2c-board-info-结构体" class="headerlink" title="1.3.6. i2c_board_info 结构体"></a>1.3.6. i2c_board_info 结构体</h3><p>描述了板载的I2C设备信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_board_info &#123;	</span><br><span class="line">    char		type[I2C_NAME_SIZE];//client 名	</span><br><span class="line">    unsigned short	flags;//client标志位	</span><br><span class="line">    unsigned short	addr;//client地址	</span><br><span class="line">    const char	*dev_name;//	</span><br><span class="line">    void		*platform_data;	</span><br><span class="line">    struct device_node *of_node;//平台设备节点	</span><br><span class="line">    struct fwnode_handle *fwnode;	</span><br><span class="line">    const struct property_entry *properties;	</span><br><span class="line">    const struct resource *resources;	</span><br><span class="line">    unsigned int	num_resources;	</span><br><span class="line">    int		irq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-7-device-node-结构体"><a href="#1-3-7-device-node-结构体" class="headerlink" title="1.3.7. device_node 结构体"></a>1.3.7. device_node 结构体</h3><p>此数据结构不是设备模型中的，它是一个DTS中节点对应的内存中设备描述，一般代表一个设备。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct device_node &#123;</span><br><span class="line">	const char *name;//设备的初始名称</span><br><span class="line">	const char *type;//设备属性名称</span><br><span class="line">	phandle phandle;//phandle属性值</span><br><span class="line">	const char *full_name;//指向该结构体结束的位置，存放node的路径全名</span><br><span class="line"></span><br><span class="line">	struct	property *properties;//指向该节点下的第一个属性，其他属性与该属性链表相接</span><br><span class="line">	struct	property *deadprops;	/* removed properties */</span><br><span class="line">	struct	device_node *parent;//父节点</span><br><span class="line">	struct	device_node *child;//子节点</span><br><span class="line">	struct	device_node *sibling;//兄弟节点</span><br><span class="line">	struct	device_node *next;	/* 下一台同类设备 */</span><br><span class="line">	struct	device_node *allnext;	/* 所有节点列表中的下一个 */</span><br><span class="line">	struct	kobject kobj;//sysfs文件系统目录体现</span><br><span class="line">	unsigned long _flags;//当前node状态标志位，</span><br><span class="line">	void	*data;</span><br><span class="line">#if defined(CONFIG_SPARC)</span><br><span class="line">	const char *path_component_name;</span><br><span class="line">	unsigned int unique_id;</span><br><span class="line">	struct of_irq_controller *irq_trans;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-8-bus-type-结构体"><a href="#1-3-8-bus-type-结构体" class="headerlink" title="1.3.8. bus_type 结构体"></a>1.3.8. bus_type 结构体</h3><p>总线结构体，任何总线的基类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type &#123;</span><br><span class="line">	const char		*name;</span><br><span class="line">	const char		*dev_name;</span><br><span class="line">	struct device		*dev_root;</span><br><span class="line">	struct bus_attribute	*bus_attrs;</span><br><span class="line">	struct device_attribute	*dev_attrs;</span><br><span class="line">	struct driver_attribute	*drv_attrs;</span><br><span class="line"></span><br><span class="line">	int (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">	int (*probe)(struct device *dev);</span><br><span class="line">	int (*remove)(struct device *dev);</span><br><span class="line">	void (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	int (*suspend)(struct device *dev, pm_message_t state);</span><br><span class="line">	int (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	const struct dev_pm_ops *pm;</span><br><span class="line"></span><br><span class="line">	struct iommu_ops *iommu_ops;</span><br><span class="line"></span><br><span class="line">	struct subsys_private *p;</span><br><span class="line">	struct lock_class_key lock_key;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-各结构体的作用之间的关系"><a href="#1-4-各结构体的作用之间的关系" class="headerlink" title="1.4. 各结构体的作用之间的关系"></a><strong>1.4.</strong> 各结构体的作用之间的关系</h2><p>从i2c驱动架构图中可以看出，linux内核对i2c架构抽象了一个叫核心层core的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件事件提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。</p>
<h3 id="1-4-1-i2c-adapter与i2c-algorithm"><a href="#1-4-1-i2c-adapter与i2c-algorithm" class="headerlink" title="1.4.1. i2c_adapter与i2c_algorithm"></a>1.4.1. i2c_adapter与i2c_algorithm</h3><p>​    i2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。</p>
<p>​    i2c_algorithm中的关键函数master_xfer()用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。</p>
<p>​    i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体</p>
<h3 id="1-4-2-i2c-driver和i2c-client"><a href="#1-4-2-i2c-driver和i2c-client" class="headerlink" title="1.4.2. i2c_driver和i2c_client"></a>1.4.2. i2c_driver和i2c_client</h3><p>​    i2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()</p>
<p>​    i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述</p>
<h3 id="1-4-3-i2c-driver与i2c-client"><a href="#1-4-3-i2c-driver与i2c-client" class="headerlink" title="1.4.3. i2c_driver与i2c_client"></a>1.4.3. i2c_driver与i2c_client</h3><p>i2c_driver 对应一套驱动方法，其主要成员函数是probe()、remove()、suspend()、resume()等，另外id_table 是该驱动所支持的I2C 设备的ID 表。i2c_client 对应于真实的物理设备，每个I2C 设备都需要一个i2c_client 来描述。i2c_driver 与i2c_client 的关系是一对多，一个i2c_driver 上可以支持多个同等类型的i2c_client。</p>
<h3 id="1-4-4-i2c-adapter和i2c-client"><a href="#1-4-4-i2c-adapter和i2c-client" class="headerlink" title="1.4.4. i2c_adapter和i2c_client"></a>1.4.4. i2c_adapter和i2c_client</h3><p>i2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。</p>
<p>图2.1  I2C驱动的各数据结构的关系</p>
<h2 id="1-5-架构层次分类"><a href="#1-5-架构层次分类" class="headerlink" title="1.5. 架构层次分类"></a><strong>1.5.</strong> 架构层次分类</h2><p>​    第一层：提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。覆盖图中的硬件实现层。</p>
<p>​    第二层：提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。覆盖图中的访问抽象层、i2c核心层。</p>
<p>​    第三层：实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。覆盖图中的driver驱动层。</p>
<p>​    第四层：实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。覆盖图中的driver驱动层。</p>
<p>第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。</p>
<p><img src="/2021/07/27/I2C%E9%A9%B1%E5%8A%A8/i2c%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>​                                        图2.2 linux I2C驱动架构框图</p>
<h2 id="1-6-接口分析"><a href="#1-6-接口分析" class="headerlink" title="1.6. 接口分析"></a><strong>1.6.</strong> 接口分析</h2><h3 id="1-6-1-i2c-core"><a href="#1-6-1-i2c-core" class="headerlink" title="1.6.1. i2c_core"></a>1.6.1. i2c_core</h3><h4 id="1-6-1-1-i2c-init-函数"><a href="#1-6-1-1-i2c-init-函数" class="headerlink" title="**1.6.1.1.**i2c_init() 函数"></a>**1.6.1.1.**i2c_init() 函数</h4><p>i2c初始化函数，先注册I2C总线，i2c_bus_type基类型是bus_type结构体类型，注册i2c驱动i2c_add_driver()该函数会调用i2c_regiser_driver()。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static int __init i2c_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int retval;</span><br><span class="line"></span><br><span class="line">	retval = bus_register(&amp;i2c_bus_type);//先注册i2c总线，</span><br><span class="line">	if (retval)</span><br><span class="line">		return retval;</span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">	i2c_adapter_compat_class = class_compat_register(&quot;i2c-adapter&quot;);</span><br><span class="line">	if (!i2c_adapter_compat_class) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		goto bus_err;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">	retval = i2c_add_driver(&amp;dummy_driver);//增加驱动</span><br><span class="line">	if (retval)</span><br><span class="line">		goto class_err;</span><br><span class="line"></span><br><span class="line">	if (IS_ENABLED(CONFIG_OF_DYNAMIC))</span><br><span class="line">		WARN_ON(of_reconfig_notifier_register(&amp;i2c_of_notifier));</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-2-bus-register"><a href="#1-6-1-2-bus-register" class="headerlink" title="1.6.1.2. bus_register()"></a><strong>1.6.1.2.</strong> bus_register()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">int bus_register(struct bus_type *bus)</span><br><span class="line">&#123;</span><br><span class="line">	int retval;</span><br><span class="line">	struct subsys_private *priv;</span><br><span class="line">	struct lock_class_key *key = &amp;bus-&gt;lock_key;</span><br><span class="line"></span><br><span class="line">	priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL);//申请私有空间</span><br><span class="line">	if (!priv)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	priv-&gt;bus = bus;//私有空间关联到总线</span><br><span class="line">	bus-&gt;p = priv;//总线挂载关联空间</span><br><span class="line"></span><br><span class="line">	BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class="line"></span><br><span class="line">	retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, &quot;%s&quot;, bus-&gt;name);//起名字</span><br><span class="line">	if (retval)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	priv-&gt;subsys.kobj.kset = bus_kset;</span><br><span class="line">	priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</span><br><span class="line">	priv-&gt;drivers_autoprobe = 1;</span><br><span class="line"></span><br><span class="line">	retval = kset_register(&amp;priv-&gt;subsys);//初始化并添加一个kset</span><br><span class="line">	if (retval)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	retval = bus_create_file(bus, &amp;bus_attr_uevent);//创建属性文件</span><br><span class="line">	if (retval)</span><br><span class="line">		goto bus_uevent_fail;</span><br><span class="line"></span><br><span class="line">	priv-&gt;devices_kset = kset_create_and_add(&quot;devices&quot;, NULL,//设备kset创建命名</span><br><span class="line">						 &amp;priv-&gt;subsys.kobj);</span><br><span class="line">	if (!priv-&gt;devices_kset) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		goto bus_devices_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv-&gt;drivers_kset = kset_create_and_add(&quot;drivers&quot;, NULL,//驱动kset创建命名</span><br><span class="line">						 &amp;priv-&gt;subsys.kobj);</span><br><span class="line">	if (!priv-&gt;drivers_kset) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		goto bus_drivers_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;priv-&gt;interfaces);</span><br><span class="line">	__mutex_init(&amp;priv-&gt;mutex, &quot;subsys mutex&quot;, key);</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_drivers, NULL, NULL);//初始化总线的设备驱动</span><br><span class="line"></span><br><span class="line">	retval = add_probe_files(bus);//创建两个属性文件</span><br><span class="line">	if (retval)</span><br><span class="line">		goto bus_probe_files_fail;</span><br><span class="line"></span><br><span class="line">	retval = bus_add_attrs(bus);//创建属性文件</span><br><span class="line">	if (retval)</span><br><span class="line">		goto bus_attrs_fail;</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;bus: &#x27;%s&#x27;: registered\n&quot;, bus-&gt;name);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-3-i2c-register-driver"><a href="#1-6-1-3-i2c-register-driver" class="headerlink" title="1.6.1.3. i2c_register_driver()"></a><strong>1.6.1.3.</strong> i2c_register_driver()</h4><p>i2c驱动注册函数，注册特定设备的驱动，执行i2c_bus_type成员的参数填充。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span><br><span class="line">&#123;</span><br><span class="line">	int res;</span><br><span class="line"></span><br><span class="line">	/* Can&#x27;t register until after driver model init */</span><br><span class="line">	if (unlikely(WARN_ON(!i2c_bus_type.p)))</span><br><span class="line">		return -EAGAIN;</span><br><span class="line"></span><br><span class="line">	/* add the driver to the list of i2c drivers in the driver core */</span><br><span class="line">	driver-&gt;driver.owner = owner;</span><br><span class="line">	driver-&gt;driver.bus = &amp;i2c_bus_type;//把驱动关联到i2c总线</span><br><span class="line"></span><br><span class="line">	/* When registration returns, the driver core</span><br><span class="line">	 * will have called probe() for all matching-but-unbound devices.</span><br><span class="line">	 */</span><br><span class="line">	res = driver_register(&amp;driver-&gt;driver);//注册i2c驱动里的基础驱动</span><br><span class="line">	if (res)</span><br><span class="line">		return res;</span><br><span class="line"></span><br><span class="line">	/* Drivers should switch to dev_pm_ops instead. */</span><br><span class="line">	if (driver-&gt;suspend)</span><br><span class="line">		pr_warn(&quot;i2c-core: driver [%s] using legacy suspend method\n&quot;,</span><br><span class="line">			driver-&gt;driver.name);</span><br><span class="line">	if (driver-&gt;resume)</span><br><span class="line">		pr_warn(&quot;i2c-core: driver [%s] using legacy resume method\n&quot;,</span><br><span class="line">			driver-&gt;driver.name);</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;i2c-core: driver [%s] registered\n&quot;, driver-&gt;driver.name);</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;driver-&gt;clients);</span><br><span class="line">	/* Walk the adapters that are already present */</span><br><span class="line">	i2c_for_each_dev(driver, __process_new_driver);//遍历总线的设备，已增加新的驱动</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-4-driver-register"><a href="#1-6-1-4-driver-register" class="headerlink" title="1.6.1.4. driver_register()"></a><strong>1.6.1.4.</strong> driver_register()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">int driver_register(struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct device_driver *other;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!drv-&gt;bus-&gt;p);</span><br><span class="line"></span><br><span class="line">	if ((drv-&gt;bus-&gt;probe &amp;&amp; drv-&gt;probe) ||</span><br><span class="line">	    (drv-&gt;bus-&gt;remove &amp;&amp; drv-&gt;remove) ||</span><br><span class="line">	    (drv-&gt;bus-&gt;shutdown &amp;&amp; drv-&gt;shutdown))</span><br><span class="line">		printk(KERN_WARNING &quot;Driver &#x27;%s&#x27; needs updating - please use &quot;</span><br><span class="line">			&quot;bus_type methods\n&quot;, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">	other = driver_find(drv-&gt;name, drv-&gt;bus);//查看总线上是否注册了该驱动</span><br><span class="line"></span><br><span class="line">	if (other) &#123;</span><br><span class="line">		printk(KERN_ERR &quot;Error: Driver &#x27;%s&#x27; is already registered, &quot;</span><br><span class="line">			&quot;aborting...\n&quot;, drv-&gt;name);</span><br><span class="line">		return -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = bus_add_driver(drv);//驱动添加到总线</span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line">	ret = driver_add_groups(drv, drv-&gt;groups);//添加到组，函数未实现</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		bus_remove_driver(drv);</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	kobject_uevent(&amp;drv-&gt;p-&gt;kobj, KOBJ_ADD);//通知添加事件，加载模块</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-5-i2c-add-adapter-函数"><a href="#1-6-1-5-i2c-add-adapter-函数" class="headerlink" title="1.6.1.5. i2c_add_adapter() 函数"></a><strong>1.6.1.5.</strong> i2c_add_adapter() 函数</h4><p>i2c_adapter_type结构体基类型是device_type类型。增加i2c适配器，该函数会调用i2c_register_adapter()进行i2c适配器的注册，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int i2c_add_adapter(struct i2c_adapter *adapter)</span><br><span class="line">&#123;</span><br><span class="line">	struct device *dev = &amp;adapter-&gt;dev;</span><br><span class="line">	int id;</span><br><span class="line">//判断设备是否存在</span><br><span class="line">	if (dev-&gt;of_node) &#123;//代表设备树中节点对应的内存中设备的描述</span><br><span class="line">		id = of_alias_get_id(dev-&gt;of_node, &quot;i2c&quot;);</span><br><span class="line">		if (id &gt;= 0) &#123;</span><br><span class="line">			adapter-&gt;nr = id;</span><br><span class="line">			return __i2c_add_numbered_adapter(adapter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	id = idr_alloc(&amp;i2c_adapter_idr, adapter,</span><br><span class="line">		       __i2c_first_dynamic_bus_num, 0, GFP_KERNEL);</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line">	if (id &lt; 0)</span><br><span class="line">		return id;</span><br><span class="line"></span><br><span class="line">	adapter-&gt;nr = id;</span><br><span class="line"></span><br><span class="line">	return i2c_register_adapter(adapter);//i2c适配器注册</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-6-i2c-register-adapter"><a href="#1-6-1-6-i2c-register-adapter" class="headerlink" title="1.6.1.6. i2c_register_adapter()"></a><strong>1.6.1.6.</strong> i2c_register_adapter()</h4><p>该函数调用了device_register()–device_add()进行设备的注册。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static int i2c_register_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">	rt_mutex_init(&amp;adap-&gt;bus_lock);</span><br><span class="line">	mutex_init(&amp;adap-&gt;userspace_clients_lock);//初始化互斥体</span><br><span class="line">	INIT_LIST_HEAD(&amp;adap-&gt;userspace_clients);</span><br><span class="line"></span><br><span class="line">	/* Set default timeout to 1 second if not already set */</span><br><span class="line">	if (adap-&gt;timeout == 0)</span><br><span class="line">		adap-&gt;timeout = HZ;</span><br><span class="line"></span><br><span class="line">	dev_set_name(&amp;adap-&gt;dev, &quot;i2c-%d&quot;, adap-&gt;nr);</span><br><span class="line">	adap-&gt;dev.bus = &amp;i2c_bus_type;//把适配器中的设备关联到i2c总线</span><br><span class="line">	adap-&gt;dev.type = &amp;i2c_adapter_type;//把适配器中的设备关联到i2c适配器总线</span><br><span class="line">	res = device_register(&amp;adap-&gt;dev);//注册i2c适配器设备</span><br><span class="line">	if (res)</span><br><span class="line">		goto out_list;</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;adap-&gt;dev, &quot;adapter [%s] registered\n&quot;, adap-&gt;name);</span><br><span class="line"></span><br><span class="line">exit_recovery:</span><br><span class="line">	/* create pre-declared device nodes */</span><br><span class="line">	internal_of_i2c_register_devices(adap);</span><br><span class="line"></span><br><span class="line">	if (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">		i2c_scan_static_board_info(adap);</span><br><span class="line">	/* Notify drivers */</span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	bus_for_each_drv(&amp;i2c_bus_type, NULL, adap, __process_new_adapter);</span><br><span class="line">//遍历总线驱动，设备匹配驱动</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-7-device-add"><a href="#1-6-1-7-device-add" class="headerlink" title="1.6.1.7. device_add()"></a><strong>1.6.1.7.</strong> device_add()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">/ **</span><br><span class="line"> * device_add-将设备添加到设备层次结构。</span><br><span class="line"> * @dev：设备。</span><br><span class="line"> *</span><br><span class="line"> *这是device_register（）的第2部分，尽管可能被称为</span><br><span class="line"> *单独地_iff_ device_initialize（）已被单独调用。</span><br><span class="line"> *</span><br><span class="line"> *通过kobject_add（）将@dev添加到kobject层次结构中</span><br><span class="line"> *到设备的全局和同级列表，然后</span><br><span class="line"> *将其添加到驱动程序模型的其他相关子系统中。</span><br><span class="line"> *</span><br><span class="line"> *不要多次调用此例程或device_register（）</span><br><span class="line"> *任何设备结构。驱动程序模型核心并非旨在工作</span><br><span class="line"> *使用未注册的设备，然后恢复原状。</span><br><span class="line"> *（除其他事项外，很难保证所有参考</span><br><span class="line"> *删除了@dev的前一个版本。）分配</span><br><span class="line"> *并注册一个新的新struct设备。</span><br><span class="line"> *</span><br><span class="line"> *注意：_Never_会在调用此函数后直接释放@dev，即使</span><br><span class="line"> *如果返回错误！始终使用put_device（）放弃您的</span><br><span class="line"> *参考。</span><br><span class="line"> * /</span><br><span class="line">int device_add(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct device *parent = NULL;</span><br><span class="line">	struct kobject *kobj;</span><br><span class="line">	struct class_interface *class_intf;</span><br><span class="line">	int error = -EINVAL;</span><br><span class="line"></span><br><span class="line">	dev = get_device(dev);//增加引用计数</span><br><span class="line">	if (!dev)</span><br><span class="line">		goto done;</span><br><span class="line"></span><br><span class="line">	if (!dev-&gt;p) &#123;</span><br><span class="line">		error = device_private_init(dev);//私有空间申用</span><br><span class="line">		if (error)</span><br><span class="line">			goto done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * for statically allocated devices, which should all be converted</span><br><span class="line">	 * some day, we need to initialize the name. We prevent reading back</span><br><span class="line">	 * the name, and force the use of dev_name()</span><br><span class="line">	 */</span><br><span class="line">	if (dev-&gt;init_name) &#123;</span><br><span class="line">		dev_set_name(dev, &quot;%s&quot;, dev-&gt;init_name);//初始化设备内部的kobject的名字</span><br><span class="line">		dev-&gt;init_name = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	//使用bus以及设备id来初始化设备内部kobject名字</span><br><span class="line">	/* subsystems can specify simple device enumeration */</span><br><span class="line">	if (!dev_name(dev) &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_name)</span><br><span class="line">		dev_set_name(dev, &quot;%s%u&quot;, dev-&gt;bus-&gt;dev_name, dev-&gt;id);</span><br><span class="line"></span><br><span class="line">	if (!dev_name(dev)) &#123;//获得设备的名字</span><br><span class="line">		error = -EINVAL;</span><br><span class="line">		goto name_error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;device: &#x27;%s&#x27;: %s\n&quot;, dev_name(dev), __func__);</span><br><span class="line"></span><br><span class="line">	parent = get_device(dev-&gt;parent);//并增加父设备引用计数</span><br><span class="line">	kobj = get_device_parent(dev, parent);//增加设备父设备</span><br><span class="line">	if (kobj)</span><br><span class="line">		dev-&gt;kobj.parent = kobj;//在kobject层实现设备父子关系</span><br><span class="line"></span><br><span class="line">	/* use parent numa_node */</span><br><span class="line">	if (parent)</span><br><span class="line">		set_dev_node(dev, dev_to_node(parent));</span><br><span class="line"></span><br><span class="line">	/* first, register with generic layer. */</span><br><span class="line">	/* we require the name to be set before, and pass NULL */</span><br><span class="line">	//将设备加入到kobject模型中，创建sys相关目录</span><br><span class="line">	error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, NULL);</span><br><span class="line">	if (error)</span><br><span class="line">		goto Error;</span><br><span class="line"></span><br><span class="line">	/* notify platform of device entry */</span><br><span class="line">	if (platform_notify)</span><br><span class="line">		platform_notify(dev);</span><br><span class="line">	//创建sys目录下设备的uevent属性文件，通过它可以查看设备的uevent事件</span><br><span class="line">	error = device_create_file(dev, &amp;uevent_attr);</span><br><span class="line">	if (error)</span><br><span class="line">		goto attrError;</span><br><span class="line"></span><br><span class="line">	if (MAJOR(dev-&gt;devt)) &#123;//创建sys目录下设备的设备号属性，即major和minor</span><br><span class="line">		error = device_create_file(dev, &amp;devt_attr);</span><br><span class="line">		if (error)</span><br><span class="line">			goto ueventattrError;</span><br><span class="line"></span><br><span class="line">		error = device_create_sys_dev_entry(dev);</span><br><span class="line">		if (error)</span><br><span class="line">			goto devtattrError;</span><br><span class="line"></span><br><span class="line">		devtmpfs_create_node(dev);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	error = device_add_class_symlinks(dev);</span><br><span class="line">	if (error)</span><br><span class="line">		goto SymlinkError;</span><br><span class="line">	error = device_add_attrs(dev);//创建sys目录下设备其他属性文件</span><br><span class="line">	if (error)</span><br><span class="line">		goto AttrsError;</span><br><span class="line">	error = bus_add_device(dev);//将设备加入到管理它的bus总线的设备连表上</span><br><span class="line">	if (error)</span><br><span class="line">		goto BusError;</span><br><span class="line">	error = dpm_sysfs_add(dev);//电源管理相关</span><br><span class="line">	if (error)</span><br><span class="line">		goto DPMError;</span><br><span class="line">	device_pm_add(dev);</span><br><span class="line"></span><br><span class="line">	/* Notify clients of device addition.  This call must come</span><br><span class="line">	 * after dpm_sysfs_add() and before kobject_uevent().</span><br><span class="line">	 */</span><br><span class="line">	if (dev-&gt;bus)//通知注册监听该总线的设备，有新设备加入</span><br><span class="line">		blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">					     BUS_NOTIFY_ADD_DEVICE, dev);</span><br><span class="line">	</span><br><span class="line">	//产生一个内核uevent事件，该事件可以被内核以及应用层捕获，属于linux设备模型中热插拔机制</span><br><span class="line">	kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);</span><br><span class="line">	bus_probe_device(dev);//开始寻找设备所对应的驱动</span><br><span class="line">	if (parent)</span><br><span class="line">		klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,//建立设备与总线间的父子关系</span><br><span class="line">			       &amp;parent-&gt;p-&gt;klist_children);</span><br><span class="line"></span><br><span class="line">	if (dev-&gt;class) &#123;</span><br><span class="line">		mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">		/* tie the class to the device */</span><br><span class="line">		klist_add_tail(&amp;dev-&gt;knode_class,//将设备挂接在其设备类上面</span><br><span class="line">			       &amp;dev-&gt;class-&gt;p-&gt;klist_devices);</span><br><span class="line"></span><br><span class="line">		/* notify any interfaces that the device is here */</span><br><span class="line">		list_for_each_entry(class_intf,//通知有新设备加入</span><br><span class="line">				    &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)</span><br><span class="line">			if (class_intf-&gt;add_dev)</span><br><span class="line">				class_intf-&gt;add_dev(dev, class_intf);</span><br><span class="line">		mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-8-i2c-del-adapter-函数"><a href="#1-6-1-8-i2c-del-adapter-函数" class="headerlink" title="1.6.1.8. i2c_del_adapter() 函数"></a><strong>1.6.1.8.</strong> i2c_del_adapter() 函数</h4><p>删除i2c适配器，会调用i2c_unregister_device()该函数调用device_unregister()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void i2c_del_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_adapter *found;</span><br><span class="line">	struct i2c_client *client, *next;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	bus_for_each_drv(&amp;i2c_bus_type, NULL, adap,</span><br><span class="line">			       __process_removed_adapter);</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">	/* Remove devices instantiated from sysfs */</span><br><span class="line">	mutex_lock_nested(&amp;adap-&gt;userspace_clients_lock,</span><br><span class="line">			  i2c_adapter_depth(adap));</span><br><span class="line">	list_for_each_entry_safe(client, next, &amp;adap-&gt;userspace_clients,</span><br><span class="line">				 detected) &#123;</span><br><span class="line">		dev_dbg(&amp;adap-&gt;dev, &quot;Removing %s at 0x%x\n&quot;, client-&gt;name,</span><br><span class="line">			client-&gt;addr);</span><br><span class="line">		list_del(&amp;client-&gt;detected);</span><br><span class="line">		i2c_unregister_device(client);//循环注销适配器上的I2C设备</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">	/* clean up the sysfs representation */</span><br><span class="line">	init_completion(&amp;adap-&gt;dev_released);</span><br><span class="line">	device_unregister(&amp;adap-&gt;dev);</span><br><span class="line"></span><br><span class="line">	/* wait for sysfs to drop all references */</span><br><span class="line">	wait_for_completion(&amp;adap-&gt;dev_released);</span><br><span class="line"></span><br><span class="line">	/* free bus id */</span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">	/* Clear the device structure in case this adapter is ever going to be</span><br><span class="line">	   added again */</span><br><span class="line">	memset(&amp;adap-&gt;dev, 0, sizeof(adap-&gt;dev));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>1.6.1.9.</strong> i2c_unregister_device()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void i2c_unregister_device(struct i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">#if IS_ENABLED(CONFIG_OF_DYNAMIC)</span><br><span class="line">	if (client-&gt;dev.of_node)</span><br><span class="line">		of_node_clear_flag(client-&gt;dev.of_node, OF_POPULATED);</span><br><span class="line">#endif</span><br><span class="line">	device_unregister(&amp;client-&gt;dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>1.6.1.10.</strong> i2c_transfer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">		if (adap-&gt;algo-&gt;master_xfer) &#123;//传输算法存在</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">		for (ret = 0; ret &lt; num; ret++) &#123;</span><br><span class="line">			dev_dbg(&amp;adap-&gt;dev, &quot;master_xfer[%d] %c, addr=0x%02x, &quot;</span><br><span class="line">				&quot;len=%d%s\n&quot;, ret, (msgs[ret].flags &amp; I2C_M_RD)</span><br><span class="line">				? &#x27;R&#x27; : &#x27;W&#x27;, msgs[ret].addr, msgs[ret].len,</span><br><span class="line">				(msgs[ret].flags &amp; I2C_M_RECV_LEN) ? &quot;+&quot; : &quot;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line">//in_atomic()这个宏可以判断当前进程是否处于原子操作中</span><br><span class="line">//irqs_disabled()这个宏用于禁止中断</span><br><span class="line">		if (in_atomic() || irqs_disabled()) &#123;</span><br><span class="line">			ret = i2c_trylock_adapter(adap);//尝试锁</span><br><span class="line">			if (!ret)</span><br><span class="line">				/* I2C activity is ongoing. */</span><br><span class="line">				return -EAGAIN;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			i2c_lock_adapter(adap);//锁</span><br><span class="line">		&#125;</span><br><span class="line">		//该函数调用到algo文件夹里的函数</span><br><span class="line">		ret = __i2c_transfer(adap, msgs, num);</span><br><span class="line">		i2c_unlock_adapter(adap);//释放锁</span><br><span class="line"></span><br><span class="line">		return ret;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		dev_dbg(&amp;adap-&gt;dev, &quot;I2C level transfers not supported\n&quot;);</span><br><span class="line">		return -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-11-i2c-transfer"><a href="#1-6-1-11-i2c-transfer" class="headerlink" title="1.6.1.11. __i2c_transfer"></a><strong>1.6.1.11.</strong> __i2c_transfer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long orig_jiffies;</span><br><span class="line">	int ret, try;</span><br><span class="line"></span><br><span class="line">	/* Retry automatically on arbitration loss */</span><br><span class="line">	orig_jiffies = jiffies;//获得当前系统时间</span><br><span class="line">	for (ret = 0, try = 0; try &lt;= adap-&gt;retries; try++) &#123;</span><br><span class="line">		ret = adap-&gt;algo-&gt;master_xfer(adap, msgs, num);</span><br><span class="line">		if (ret != -EAGAIN)//上操作参数阻塞，则跳出</span><br><span class="line">			break;</span><br><span class="line">		if (time_after(jiffies, orig_jiffies + adap-&gt;timeout))</span><br><span class="line">			break;//超时，退出</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-12-i2c-master-send"><a href="#1-6-1-12-i2c-master-send" class="headerlink" title="1.6.1.12. i2c_master_send"></a><strong>1.6.1.12.</strong> i2c_master_send</h4><p>该芯片作为主机进行传输的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">nt i2c_master_send(const struct i2c_client *client, const char *buf, int count)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct i2c_adapter *adap = client-&gt;adapter;</span><br><span class="line">	struct i2c_msg msg;</span><br><span class="line"></span><br><span class="line">	msg.addr = client-&gt;addr;</span><br><span class="line">	msg.flags = client-&gt;flags &amp; I2C_M_TEN;</span><br><span class="line">	msg.len = count;</span><br><span class="line">	msg.buf = (char *)buf;</span><br><span class="line"></span><br><span class="line">	ret = i2c_transfer(adap, &amp;msg, 1);//实际还是调用i2c_transfer()函数</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If everything went ok (i.e. 1 msg transmitted), return #bytes</span><br><span class="line">	 * transmitted, else error code.</span><br><span class="line">	 */</span><br><span class="line">	return (ret == 1) ? count : ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>1.6.1.13.</strong> i2c_master_recv</p>
<p>作为主机进行接收信息的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int i2c_master_recv(const struct i2c_client *client, char *buf, int count)</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_adapter *adap = client-&gt;adapter;</span><br><span class="line">	struct i2c_msg msg;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	msg.addr = client-&gt;addr;</span><br><span class="line">	msg.flags = client-&gt;flags &amp; I2C_M_TEN;</span><br><span class="line">	msg.flags |= I2C_M_RD;</span><br><span class="line">	msg.len = count;</span><br><span class="line">	msg.buf = buf;</span><br><span class="line"></span><br><span class="line">	ret = i2c_transfer(adap, &amp;msg, 1);//同样调用i2c_transfer()</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If everything went ok (i.e. 1 msg received), return #bytes received,</span><br><span class="line">	 * else error code.</span><br><span class="line">	 */</span><br><span class="line">	return (ret == 1) ? count : ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-14-i2c-new-device"><a href="#1-6-1-14-i2c-new-device" class="headerlink" title="1.6.1.14. i2c_new_device"></a><strong>1.6.1.14.</strong> i2c_new_device</h4><p>创建一个I2C设备，即I2C_client,内部调用device_register()函数注册新设备,并与i2c_adapter关联。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_client *</span><br><span class="line">i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_client	*client;</span><br><span class="line">	int			status;</span><br><span class="line"></span><br><span class="line">	client = kzalloc(sizeof *client, GFP_KERNEL);//设备地址创建</span><br><span class="line">		strlcpy(client-&gt;name, info-&gt;type, sizeof(client-&gt;name));</span><br><span class="line"></span><br><span class="line">	/* Check for address validity */</span><br><span class="line">	status = i2c_check_client_addr_validity(client);</span><br><span class="line">	if (status) &#123;</span><br><span class="line">		dev_err(&amp;adap-&gt;dev, &quot;Invalid %d-bit I2C address 0x%02hx\n&quot;,</span><br><span class="line">			client-&gt;flags &amp; I2C_CLIENT_TEN ? 10 : 7, client-&gt;addr);</span><br><span class="line">		goto out_err_silent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Check for address business */</span><br><span class="line">	status = i2c_check_addr_busy(adap, client-&gt;addr);</span><br><span class="line">	if (status)//检测地址是否和其他的冲突</span><br><span class="line">		goto out_err;</span><br><span class="line"></span><br><span class="line">	/* For 10-bit clients, add an arbitrary offset to avoid collisions */</span><br><span class="line">	dev_set_name(&amp;client-&gt;dev, &quot;%d-%04x&quot;, i2c_adapter_id(adap),</span><br><span class="line">		     client-&gt;addr | ((client-&gt;flags &amp; I2C_CLIENT_TEN)</span><br><span class="line">				     ? 0xa000 : 0));</span><br><span class="line">	status = device_register(&amp;client-&gt;dev);//注册新设备</span><br><span class="line">	if (status)</span><br><span class="line">		goto out_err;</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;adap-&gt;dev, &quot;client [%s] registered with bus id %s\n&quot;,</span><br><span class="line">		client-&gt;name, dev_name(&amp;client-&gt;dev));</span><br><span class="line"></span><br><span class="line">	return client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-15-i2c-unregister-device"><a href="#1-6-1-15-i2c-unregister-device" class="headerlink" title="1.6.1.15. i2c_unregister_device"></a><strong>1.6.1.15.</strong> i2c_unregister_device</h4><p>注销一个I2C设备，即I2C client，内部调用device_unregister()函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void i2c_unregister_device(struct i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">#if IS_ENABLED(CONFIG_OF_DYNAMIC)</span><br><span class="line">	if (client-&gt;dev.of_node)</span><br><span class="line">		of_node_clear_flag(client-&gt;dev.of_node, OF_POPULATED);</span><br><span class="line">#endif</span><br><span class="line">	device_unregister(&amp;client-&gt;dev);//注销设备</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-16-i2c-register-driver-函数"><a href="#1-6-1-16-i2c-register-driver-函数" class="headerlink" title="1.6.1.16. i2c_register_driver() 函数"></a><strong>1.6.1.16.</strong> i2c_register_driver() 函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#define i2c_add_driver(driver) \</span><br><span class="line">	i2c_register_driver(THIS_MODULE, driver)</span><br><span class="line"></span><br><span class="line">int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span><br><span class="line">&#123;</span><br><span class="line">	int res;</span><br><span class="line"></span><br><span class="line">	/* Can&#x27;t register until after driver model init */</span><br><span class="line">	if (unlikely(WARN_ON(!i2c_bus_type.p)))</span><br><span class="line">		return -EAGAIN;</span><br><span class="line"></span><br><span class="line">	/* add the driver to the list of i2c drivers in the driver core */</span><br><span class="line">	driver-&gt;driver.owner = owner;</span><br><span class="line">	driver-&gt;driver.bus = &amp;i2c_bus_type;//关联总线</span><br><span class="line"></span><br><span class="line">	/* When registration returns, the driver core</span><br><span class="line">	 * will have called probe() for all matching-but-unbound devices.</span><br><span class="line">	 */</span><br><span class="line">	res = driver_register(&amp;driver-&gt;driver);//调用驱动注册</span><br><span class="line">	if (res)</span><br><span class="line">		return res;</span><br><span class="line"></span><br><span class="line">	/* Drivers should switch to dev_pm_ops instead. */</span><br><span class="line">	if (driver-&gt;suspend)</span><br><span class="line">		pr_warn(&quot;i2c-core: driver [%s] using legacy suspend method\n&quot;,</span><br><span class="line">			driver-&gt;driver.name);</span><br><span class="line">	if (driver-&gt;resume)</span><br><span class="line">		pr_warn(&quot;i2c-core: driver [%s] using legacy resume method\n&quot;,</span><br><span class="line">			driver-&gt;driver.name);</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;i2c-core: driver [%s] registered\n&quot;, driver-&gt;driver.name);</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;driver-&gt;clients);</span><br><span class="line">	/* Walk the adapters that are already present */</span><br><span class="line">	i2c_for_each_dev(driver, __process_new_driver);</span><br><span class="line">//遍历总线设备，驱动匹配设备</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-17-i2c-del-driver-函数"><a href="#1-6-1-17-i2c-del-driver-函数" class="headerlink" title="1.6.1.17. i2c_del_driver() 函数"></a><strong>1.6.1.17.</strong> i2c_del_driver() 函数</h4><p>驱动删除函数，调用driver_unregister(&amp;driver-&gt;driver);是否添加驱动时申请的资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void i2c_del_driver(struct i2c_driver *driver)</span><br><span class="line">&#123;</span><br><span class="line">	i2c_for_each_dev(driver, __process_removed_driver);</span><br><span class="line">//遍历总线设备，驱动删除</span><br><span class="line">	driver_unregister(&amp;driver-&gt;driver);</span><br><span class="line">	pr_debug(&quot;i2c-core: driver [%s] unregistered\n&quot;, driver-&gt;driver.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-18-of-i2c-register-device-函数"><a href="#1-6-1-18-of-i2c-register-device-函数" class="headerlink" title="1.6.1.18. of_i2c_register_device()函数"></a><strong>1.6.1.18.</strong> of_i2c_register_device()函数</h4><p>根据设备节点的信息在adap下注册设备。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">static struct i2c_client *of_i2c_register_device(struct i2c_adapter *adap,</span><br><span class="line">						 struct device_node *node)</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_client *result;</span><br><span class="line">	struct i2c_board_info info = &#123;&#125;;</span><br><span class="line">	struct dev_archdata dev_ad = &#123;&#125;;</span><br><span class="line">	const __be32 *addr;</span><br><span class="line">	int len;</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;adap-&gt;dev, &quot;of_i2c: register %s\n&quot;, node-&gt;full_name);</span><br><span class="line"></span><br><span class="line">	if (of_modalias_node(node, info.type, sizeof(info.type)) &lt; 0) &#123;</span><br><span class="line">		dev_err(&amp;adap-&gt;dev, &quot;of_i2c: modalias failure on %s\n&quot;,</span><br><span class="line">			node-&gt;full_name);</span><br><span class="line">		return ERR_PTR(-EINVAL);</span><br><span class="line">	&#125;//判断compaibel值</span><br><span class="line"></span><br><span class="line">	addr = of_get_property(node, &quot;reg&quot;, &amp;len);//从设备节点获得设备地址</span><br><span class="line">	//根据2参数，在指定的设备结点1中查找匹配的property，并返回这个property的属性值</span><br><span class="line">	if (!addr || (len &lt; sizeof(int))) &#123;</span><br><span class="line">		dev_err(&amp;adap-&gt;dev, &quot;of_i2c: invalid reg on %s\n&quot;,</span><br><span class="line">			node-&gt;full_name);</span><br><span class="line">		return ERR_PTR(-EINVAL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	info.addr = be32_to_cpup(addr);//把从设备节点获得的设备地址给info</span><br><span class="line">	if (info.addr &gt; (1 &lt;&lt; 10) - 1) &#123;</span><br><span class="line">		dev_err(&amp;adap-&gt;dev, &quot;of_i2c: invalid addr=%x on %s\n&quot;,</span><br><span class="line">			info.addr, node-&gt;full_name);</span><br><span class="line">		return ERR_PTR(-EINVAL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	info.irq = irq_of_parse_and_map(node, 0);</span><br><span class="line">	//从设备节点node中读取第index个irq号</span><br><span class="line">	info.of_node = of_node_get(node);</span><br><span class="line">	info.archdata = &amp;dev_ad;</span><br><span class="line"></span><br><span class="line">	if (of_get_property(node, &quot;wakeup-source&quot;, NULL))</span><br><span class="line">		info.flags |= I2C_CLIENT_WAKE;</span><br><span class="line"></span><br><span class="line">	request_module(&quot;%s%s&quot;, I2C_MODULE_PREFIX, info.type);</span><br><span class="line">	//使用用户模式加载程序加载模块。</span><br><span class="line"></span><br><span class="line">	result = i2c_new_device(adap, &amp;info);//注册设备</span><br><span class="line">	if (result == NULL) &#123;</span><br><span class="line">		dev_err(&amp;adap-&gt;dev, &quot;of_i2c: Failure registering %s\n&quot;,</span><br><span class="line">			node-&gt;full_name);</span><br><span class="line">		of_node_put(node);</span><br><span class="line">		irq_dispose_mapping(info.irq);</span><br><span class="line">		return ERR_PTR(-EINVAL);</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-2-i2c-dev-c"><a href="#1-6-2-i2c-dev-c" class="headerlink" title="1.6.2. i2c_dev.c"></a>1.6.2. i2c_dev.c</h3><h4 id="1-6-2-1-i2c-dev-init-函数"><a href="#1-6-2-1-i2c-dev-init-函数" class="headerlink" title="1.6.2.1. i2c_dev_init() 函数"></a><strong>1.6.2.1.</strong> i2c_dev_init() 函数</h4><p>该初始化函数会注册字符设备，调用__register_chrdev()内核函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static int __init i2c_dev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int res;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO &quot;i2c /dev entries driver\n&quot;);</span><br><span class="line"></span><br><span class="line">	res = register_chrdev(I2C_MAJOR, &quot;i2c&quot;, &amp;i2cdev_fops);</span><br><span class="line">//注册字符设备，操作函数集</span><br><span class="line"></span><br><span class="line">	i2c_dev_class = class_create(THIS_MODULE, &quot;i2c-dev&quot;);//创建类节点，并注册进内核</span><br><span class="line"></span><br><span class="line">	/* 对总线注册可阻塞通知链 */</span><br><span class="line">	res = bus_register_notifier(&amp;i2c_bus_type, &amp;i2cdev_notifier);</span><br><span class="line"></span><br><span class="line">	/* 遍历总线的设备，并把设备立即绑定到该适配器*/</span><br><span class="line">	i2c_for_each_dev(NULL, i2cdev_attach_adapter);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2-2-register-chrdev"><a href="#1-6-2-2-register-chrdev" class="headerlink" title="1.6.2.2. __register_chrdev()"></a><strong>1.6.2.2.</strong> __register_chrdev()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int __register_chrdev(unsigned int major, unsigned int baseminor,</span><br><span class="line">		      unsigned int count, const char *name,</span><br><span class="line">		      const struct file_operations *fops)</span><br><span class="line">&#123;</span><br><span class="line">	struct char_device_struct *cd;//字符设备结构体指针，用于检测存储使用</span><br><span class="line">	struct cdev *cdev;//字符型设备，真正的实用的</span><br><span class="line">	int err = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	cd = __register_chrdev_region(major, baseminor, count, name);//填充</span><br><span class="line"></span><br><span class="line">	cdev = cdev_alloc();//分配字符设备内存</span><br><span class="line">	if (!cdev)</span><br><span class="line">		goto out2;</span><br><span class="line"></span><br><span class="line">	cdev-&gt;owner = fops-&gt;owner;</span><br><span class="line">	cdev-&gt;ops = fops;</span><br><span class="line">	kobject_set_name(&amp;cdev-&gt;kobj, &quot;%s&quot;, name);//设置设备用户，文件操作指针，设备名称</span><br><span class="line"></span><br><span class="line">	err = cdev_add(cdev, MKDEV(cd-&gt;major, baseminor), count);</span><br><span class="line">	//添加设备到系统中module结构体链表中，使之模块立即生效。此后文件操作，可以正常使用</span><br><span class="line"></span><br><span class="line">	cd-&gt;cdev = cdev;</span><br><span class="line"></span><br><span class="line">	return major ? 0 : cd-&gt;major;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <strong>1.6.2.3.</strong> cdev_add()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int cdev_add(struct cdev *p, dev_t dev, unsigned count)</span><br><span class="line">&#123;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	p-&gt;dev = dev;</span><br><span class="line">	p-&gt;count = count;</span><br><span class="line"></span><br><span class="line">	error = kobj_map(cdev_map, dev, count, NULL,</span><br><span class="line">			 exact_match, exact_lock, p);//kobj_map结构体是用来管理设备号及其对应的设备，</span><br><span class="line">//kobj_map函数就是将指定的设备号加入到该数组，</span><br><span class="line">	if (error)</span><br><span class="line">		return error;</span><br><span class="line"></span><br><span class="line">	kobject_get(p-&gt;kobj.parent);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2-4-i2cdev-open-函数"><a href="#1-6-2-4-i2cdev-open-函数" class="headerlink" title="1.6.2.4. i2cdev_open() 函数"></a><strong>1.6.2.4.</strong> i2cdev_open() 函数</h4><p>设备打开函数，通过次设备号（总线id）获取adapter，创建client结构（实际的dev设备）与adapter，driver相关联，并设置私有数据到file里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static int i2cdev_open(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int minor = iminor(inode);</span><br><span class="line">	struct i2c_client *client;</span><br><span class="line">	struct i2c_adapter *adap;</span><br><span class="line">	struct i2c_dev *i2c_dev;</span><br><span class="line"></span><br><span class="line">	i2c_dev = i2c_dev_get_by_minor(minor);//以次设备号从i2c_dev_list获得</span><br><span class="line">	if (!i2c_dev)</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">	adap = i2c_get_adapter(i2c_dev-&gt;adap-&gt;nr);</span><br><span class="line">//以adapter的总线号从i2c_adapter_idr中找到adapter</span><br><span class="line">	if (!adap)</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">	client = kzalloc(sizeof(*client), GFP_KERNEL);//分配，初始化，未注册</span><br><span class="line">	if (!client) &#123;</span><br><span class="line">		i2c_put_adapter(adap);</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	snprintf(client-&gt;name, I2C_NAME_SIZE, &quot;i2c-dev %d&quot;, adap-&gt;nr);</span><br><span class="line"></span><br><span class="line">	client-&gt;adapter = adap;</span><br><span class="line">	file-&gt;private_data = client;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2-5-i2cdev-read-函数"><a href="#1-6-2-5-i2cdev-read-函数" class="headerlink" title="1.6.2.5. i2cdev_read() 函数"></a><strong>1.6.2.5.</strong> i2cdev_read() 函数</h4><p>首先从file结构中取得struct i2c_client，然后在kernel分配相同长度的缓存区，随之调用i2c_master_recv()从设备中读取数据，在将读取出来的数据copy到用户空间中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t i2cdev_read(struct file *file, char __user *buf, size_t count,</span><br><span class="line">		loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">	char *tmp;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	struct i2c_client *client = file-&gt;private_data;//从文件获取client</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	if (count &gt; 8192)</span><br><span class="line">		count = 8192;</span><br><span class="line"></span><br><span class="line">	tmp = kmalloc(count, GFP_KERNEL);//申请储存空间地址</span><br><span class="line">	if (tmp == NULL)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;i2c-dev: i2c-%d reading %zu bytes.\n&quot;,</span><br><span class="line">		iminor(file_inode(file)), count);</span><br><span class="line"></span><br><span class="line">	ret = i2c_master_recv(client, tmp, count);//接收</span><br><span class="line">	if (ret &gt;= 0)</span><br><span class="line">		ret = copy_to_user(buf, tmp, count) ? -EFAULT : ret;//从内核态复制到用户态</span><br><span class="line">	kfree(tmp);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2-6-i2cdev-write-函数"><a href="#1-6-2-6-i2cdev-write-函数" class="headerlink" title="1.6.2.6. i2cdev_write() 函数"></a><strong>1.6.2.6.</strong> i2cdev_write() 函数</h4><p>将用户空间的数据通过使用函数i2c_master_send发送到i2c设备。memdup_user()函数完成分配存储区，把应用层的数据复制到刚分配的存储区中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t i2cdev_write(struct file *file, const char __user *buf,</span><br><span class="line">		size_t count, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	char *tmp;</span><br><span class="line">	struct i2c_client *client = file-&gt;private_data;//自定义设备结构体的地址</span><br><span class="line"></span><br><span class="line">	tmp = memdup_user(buf, count);//从用户态拷贝到内核态</span><br><span class="line">		ret = i2c_master_send(client, tmp, count);//发送数据</span><br><span class="line">	kfree(tmp);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2-7-i2cdev-ioctl-函数"><a href="#1-6-2-7-i2cdev-ioctl-函数" class="headerlink" title="1.6.2.7. i2cdev_ioctl() 函数"></a><strong>1.6.2.7.</strong> i2cdev_ioctl() 函数</h4><p>IO控制，主要设置从设备地址，使能读写，超时和重入次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">static long i2cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_client *client = file-&gt;private_data;</span><br><span class="line">	unsigned long funcs;</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;client-&gt;adapter-&gt;dev, &quot;ioctl, cmd=0x%02x, arg=0x%02lx\n&quot;,</span><br><span class="line">		cmd, arg);</span><br><span class="line"></span><br><span class="line">	switch (cmd) &#123;</span><br><span class="line">	case I2C_SLAVE:</span><br><span class="line">	case I2C_SLAVE_FORCE:</span><br><span class="line">	</span><br><span class="line">		if ((arg &gt; 0x3ff) ||</span><br><span class="line">		    (((client-&gt;flags &amp; I2C_M_TEN) == 0) &amp;&amp; arg &gt; 0x7f))</span><br><span class="line">			return -EINVAL;</span><br><span class="line">		if (cmd == I2C_SLAVE &amp;&amp; i2cdev_check_addr(client-&gt;adapter, arg))</span><br><span class="line">			return -EBUSY;</span><br><span class="line">		/* REVISIT: address could become busy later */</span><br><span class="line">		client-&gt;addr = arg;</span><br><span class="line">		return 0;</span><br><span class="line">	case I2C_TENBIT:</span><br><span class="line">//设置10bit地址模式</span><br><span class="line">		if (arg)</span><br><span class="line">			client-&gt;flags |= I2C_M_TEN;</span><br><span class="line">		else</span><br><span class="line">			client-&gt;flags &amp;= ~I2C_M_TEN;</span><br><span class="line">		return 0;</span><br><span class="line">	case I2C_PEC:</span><br><span class="line">//设置传输增加pec标志</span><br><span class="line">		if (arg)</span><br><span class="line">			client-&gt;flags |= I2C_CLIENT_PEC;</span><br><span class="line">		else</span><br><span class="line">			client-&gt;flags &amp;= ~I2C_CLIENT_PEC;</span><br><span class="line">		return 0;</span><br><span class="line">	case I2C_FUNCS:</span><br><span class="line">//获取函数支持</span><br><span class="line">		funcs = i2c_get_functionality(client-&gt;adapter);</span><br><span class="line">		return put_user(funcs, (unsigned long __user *)arg);</span><br><span class="line"></span><br><span class="line">	case I2C_RDWR:</span><br><span class="line">//读取和接收数据</span><br><span class="line">		return i2cdev_ioctl_rdrw(client, arg);</span><br><span class="line"></span><br><span class="line">	case I2C_SMBUS:</span><br><span class="line">//smbus协议数据传输</span><br><span class="line">		return i2cdev_ioctl_smbus(client, arg);</span><br><span class="line"></span><br><span class="line">	case I2C_RETRIES:</span><br><span class="line">//设置重试次数</span><br><span class="line">		client-&gt;adapter-&gt;retries = arg;</span><br><span class="line">		break;</span><br><span class="line">	case I2C_TIMEOUT:</span><br><span class="line">//设置超时时间</span><br><span class="line">		/* For historical reasons, user-space sets the timeout</span><br><span class="line">		 * value in units of 10 ms.</span><br><span class="line">		 */</span><br><span class="line">		client-&gt;adapter-&gt;timeout = msecs_to_jiffies(arg * 10);</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		/* NOTE:  returning a fault code here could cause trouble</span><br><span class="line">		 * in buggy userspace code.  Some old kernel bugs returned</span><br><span class="line">		 * zero in this case, and userspace code might accidentally</span><br><span class="line">		 * have depended on that bug.</span><br><span class="line">		 */</span><br><span class="line">		return -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <strong>1.6.2.8.</strong> i2cdev_ioctl_rdrw() 函数</p>
<p>读取和接收数据函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">static noinline int i2cdev_ioctl_rdrw(struct i2c_client *client,</span><br><span class="line">		unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_rdwr_ioctl_data rdwr_arg;//包括i2c_msg和它的个数</span><br><span class="line">	struct i2c_msg *rdwr_pa;</span><br><span class="line">	u8 __user **data_ptrs;</span><br><span class="line">	int i, res;</span><br><span class="line"></span><br><span class="line">	if (copy_from_user(&amp;rdwr_arg,</span><br><span class="line">			   (struct i2c_rdwr_ioctl_data __user *)arg,</span><br><span class="line">			   sizeof(rdwr_arg)))</span><br><span class="line">		return -EFAULT;</span><br><span class="line"></span><br><span class="line">	/* Put an arbitrary limit on the number of messages that can</span><br><span class="line">	 * be sent at once */</span><br><span class="line">	if (rdwr_arg.nmsgs &gt; I2C_RDRW_IOCTL_MAX_MSGS)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	rdwr_pa = memdup_user(rdwr_arg.msgs,</span><br><span class="line">			      rdwr_arg.nmsgs * sizeof(struct i2c_msg));</span><br><span class="line">	if (IS_ERR(rdwr_pa))</span><br><span class="line">		return PTR_ERR(rdwr_pa);</span><br><span class="line"></span><br><span class="line">	data_ptrs = kmalloc(rdwr_arg.nmsgs * sizeof(u8 __user *), GFP_KERNEL);</span><br><span class="line">	//创建存储I2C_MSG的内存</span><br><span class="line">if (data_ptrs == NULL) &#123;</span><br><span class="line">		kfree(rdwr_pa);</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res = 0;</span><br><span class="line">	for (i = 0; i &lt; rdwr_arg.nmsgs; i++) &#123;</span><br><span class="line">		/* Limit the size of the message to a sane amount */</span><br><span class="line">		if (rdwr_pa[i].len &gt; 8192) &#123;</span><br><span class="line">			res = -EINVAL;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		data_ptrs[i] = (u8 __user *)rdwr_pa[i].buf;</span><br><span class="line">		rdwr_pa[i].buf = memdup_user(data_ptrs[i], rdwr_pa[i].len);</span><br><span class="line">		if (IS_ERR(rdwr_pa[i].buf)) &#123;</span><br><span class="line">			res = PTR_ERR(rdwr_pa[i].buf);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (rdwr_pa[i].flags &amp; I2C_M_RECV_LEN) &#123;</span><br><span class="line">			if (!(rdwr_pa[i].flags &amp; I2C_M_RD) ||</span><br><span class="line">			    rdwr_pa[i].buf[0] &lt; 1 ||</span><br><span class="line">			    rdwr_pa[i].len &lt; rdwr_pa[i].buf[0] +</span><br><span class="line">					     I2C_SMBUS_BLOCK_MAX) &#123;</span><br><span class="line">				res = -EINVAL;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			rdwr_pa[i].len = rdwr_pa[i].buf[0];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (res &lt; 0) &#123;</span><br><span class="line">		int j;</span><br><span class="line">		for (j = 0; j &lt; i; ++j)</span><br><span class="line">			kfree(rdwr_pa[j].buf);</span><br><span class="line">		kfree(data_ptrs);</span><br><span class="line">		kfree(rdwr_pa);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res = i2c_transfer(client-&gt;adapter, rdwr_pa, rdwr_arg.nmsgs);</span><br><span class="line">//传输数据，调用i2c_transfer</span><br><span class="line">	while (i-- &gt; 0) &#123;</span><br><span class="line">		if (res &gt;= 0 &amp;&amp; (rdwr_pa[i].flags &amp; I2C_M_RD)) &#123;</span><br><span class="line">			if (copy_to_user(data_ptrs[i], rdwr_pa[i].buf,</span><br><span class="line">					 rdwr_pa[i].len))//将接收到的数据发送到应用层</span><br><span class="line">				res = -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">		kfree(rdwr_pa[i].buf);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(data_ptrs);</span><br><span class="line">	kfree(rdwr_pa);</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-6-2-9-IOCTL控制"><a href="#1-6-2-9-IOCTL控制" class="headerlink" title="1.6.2.9. IOCTL控制"></a><strong>1.6.2.9.</strong> IOCTL控制</h4><p>查看include/uapi/linux/i2c_dev.h，可以看到i2c_dev支持的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define I2C_RETRIES	0x0701	/* 未确认时应轮询设备地址的次数 */</span><br><span class="line">#define I2C_TIMEOUT	0x0702	/* 以10 ms为单位设置超时 */</span><br><span class="line"></span><br><span class="line">/ * 注：从机地址为7位或10位，但10位地址</span><br><span class="line">*不支持！（由于代码中断）</span><br><span class="line"> */</span><br><span class="line">#define I2C_SLAVE	0x0703	/* 使用这个从机地址 */</span><br><span class="line">#define I2C_SLAVE_FORCE	0x0706	/* 使用这个从机地址，即使驱动程序已经在使用它！ */</span><br><span class="line">#define I2C_TENBIT	0x0704	/* 0表示7位地址，！=0（10位） */</span><br><span class="line"></span><br><span class="line">#define I2C_FUNCS	0x0705	/* 获取适配器功能掩码 */</span><br><span class="line"></span><br><span class="line">#define I2C_RDWR	0x0707	/* 组合R/W传输（仅限一站式） */</span><br><span class="line"></span><br><span class="line">#define I2C_PEC		0x0708	/* ！=0将pec与smbus一起使用 */</span><br><span class="line">#define I2C_SMBUS	0x0720	/* SMBus 传输 */</span><br></pre></td></tr></table></figure>

<h3 id="1-6-3-用户空间使用i2c-dev"><a href="#1-6-3-用户空间使用i2c-dev" class="headerlink" title="1.6.3. 用户空间使用i2c_dev"></a>1.6.3. 用户空间使用i2c_dev</h3><p>即利用i2c-dev.c操作适配器，进而控制i2c设备， i2c-dev.c并没有针对特定的设备而设计，只是提供了通用的read()、write()和ioctl()等接口，应用层可以借用这些接口访问挂接在适配器上的i2c设备的存储空间或寄存器，并控制I2C设备的工作方式。</p>
<p>对于注册的i2c适配器，用户空间可以使用它们。上面的驱动对每个适配器生成一个主设备号为89的设备节点，实现了文件操作接口，用户空间可以通过i2c设备节点访问i2c适配器。适配器的编号从0开始，和适配器的设备节点的次设备号相同。i2c适配器的设备节点是/dev/i2c-x，其中x是数字，代表适配器的编号。由于适配器编号是动态分配的（和注册次序有关），了解哪一个适配器对应什么编号，可以查看/sys/class/i2c-dev/目录下的文件内容。</p>
<h4 id="1-6-3-1-read-和write"><a href="#1-6-3-1-read-和write" class="headerlink" title="1.6.3.1. read()和write()"></a><strong>1.6.3.1.</strong> read()和write()</h4><p>需要特别注意的是：i2c-dev.c的read()、write()方法都只适合于如下方式的数据格式（单开始信号时序）和适配器支持I2C算法的情况，不适用于（多开始信号时序）和只支持smbus算法的情况。</p>
<h4 id="1-6-3-2-iotcl"><a href="#1-6-3-2-iotcl" class="headerlink" title="1.6.3.2. iotcl()"></a><strong>1.6.3.2.</strong> iotcl()</h4><p>所以一般都不用i2c-dev.c的read()、write()方法。常用iotcl()方法，该方法可以实现所有的情况。</p>
<p>针对i2c算法，常用结构和I2C_RDWR命令。</p>
<p>常用结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_rdwr_ioctl_data &#123;</span><br><span class="line">	struct i2c_msg __user *msgs;	/* pointers to i2c_msgs */</span><br><span class="line">	__u32 nmsgs;			/* number of i2c_msgs */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct i2c_msg &#123;</span><br><span class="line">	__u16 addr;	/* 从设备地址 */</span><br><span class="line"> 	__u16 flags;	/* 设备标示 */	</span><br><span class="line"> 	__u16 len;		/* msg 长度 */</span><br><span class="line"> 	__u8 *buf;		/* msg数据指针	*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-3-3-使用流程"><a href="#1-6-3-3-使用流程" class="headerlink" title="1.6.3.3. 使用流程"></a><strong>1.6.3.3.</strong> 使用流程</h4><p>设所用的I2C适配器的设备文件为：/dev/i2c-0, 接下来是使用流程：</p>
<p>1、打开适配器文件, 并做相应的设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">i2c_rdwr_ioctl_data i2c_data;</span><br><span class="line"></span><br><span class="line">fd_X= open(XXX_FILE, O_RDWR);  /*打开适配器文件*/</span><br><span class="line"></span><br><span class="line">if(fd_X &lt; 0)</span><br><span class="line">return PTR_ERR(fd);</span><br><span class="line"></span><br><span class="line">ioctl(fd_X,I2C_SLAVE, XXX_I2C_ADDR);  /*配置slave地址*/</span><br><span class="line"></span><br><span class="line">ioctl(fd_X,I2C_TIMEOUT, 10);  /*配置超时时间*/</span><br><span class="line"></span><br><span class="line">ioctl(fd_X,I2C_RETRIES, 2);    /*配置重试次数*/</span><br><span class="line"></span><br><span class="line">/*initializei2c_data*/ /*初始化I2C通信的核心数据结构*/</span><br><span class="line"></span><br><span class="line">i2c_data.nmsgs= 2;    /*max 2 message*/</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">i2c_data.msgs= malloc(i2c_data.nmsgs * sizeof(struct i2c_msg));</span><br><span class="line"></span><br><span class="line">if(i2c_data.msgs== NULL) </span><br><span class="line"></span><br><span class="line">msgs[0]= i2c_data.msgs;</span><br><span class="line"></span><br><span class="line">msgs[1]= i2c_data.msgs + 1;</span><br><span class="line"></span><br><span class="line">msgs[0]-&gt;buf= malloc(2);  /*根据要传输的字节数来分配*/</span><br><span class="line"></span><br><span class="line">if(!msgs[0]-&gt;buf)&#123;</span><br><span class="line"></span><br><span class="line">           return PTR_ERR(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msgs[1]-&gt;buf= malloc(2);  /*根据要传输的字节数来分配*/</span><br><span class="line"></span><br><span class="line">if(!msgs[1]-&gt;buf)&#123;</span><br><span class="line"></span><br><span class="line">           return PTR_ERR(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、写寄存器流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">structi2c_msg *p_msg = i2c_data.msgs;</span><br><span class="line"></span><br><span class="line">if(fd_X &lt; 0)</span><br><span class="line"></span><br><span class="line">           return-1;</span><br><span class="line"></span><br><span class="line">/*justset i2c_data*/</span><br><span class="line"></span><br><span class="line">i2c_data.nmsgs= 1;  /*写的话只要一个msg即可*/</span><br><span class="line"></span><br><span class="line">p_msg-&gt;len= 2;</span><br><span class="line"></span><br><span class="line">p_msg-&gt;addr= XXX_I2C_ADDR;</span><br><span class="line"></span><br><span class="line">p_msg-&gt;flags= 0;     /*write*/</span><br><span class="line"></span><br><span class="line">p_msg-&gt;buf[0]= reg;   /*register*/</span><br><span class="line"></span><br><span class="line">p_msg-&gt;buf[1]= val;   /*data*/</span><br><span class="line"></span><br><span class="line">ret =ioctl(fd_X, I2C_RDWR, (unsigned long) &amp;i2c_data);  /*发送命令给适配器*/</span><br><span class="line"></span><br><span class="line">if(ret&lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">           PTR_ERR(ret);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、读寄存器的流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">int ret= 0;</span><br><span class="line"></span><br><span class="line">structi2c_msg *msgs[2]; /*读需要两个msg, 1个用来发读register的地址， 一个读数据*/</span><br><span class="line"></span><br><span class="line">if(fd_X &lt; 0)</span><br><span class="line"></span><br><span class="line">           return-1;</span><br><span class="line"></span><br><span class="line">msgs[0]= i2c_data.msgs;</span><br><span class="line"></span><br><span class="line">msgs[1]= i2c_data.msgs + 1;</span><br><span class="line"></span><br><span class="line">/*justset i2c_data*/</span><br><span class="line"></span><br><span class="line">i2c_data.nmsgs= 2;</span><br><span class="line"></span><br><span class="line">/*指定要读的寄存器地址的msg*/</span><br><span class="line"></span><br><span class="line">msgs[0]-&gt;len= 1;</span><br><span class="line"></span><br><span class="line">msgs[0]-&gt;addr= XXX_I2C_ADDR;</span><br><span class="line"></span><br><span class="line">msgs[0]-&gt;flags= 0;   /*write*/</span><br><span class="line"></span><br><span class="line">msgs[0]-&gt;buf[0]= reg;   /*register*/</span><br><span class="line"></span><br><span class="line">/*读数据*/</span><br><span class="line"></span><br><span class="line">msgs[1]-&gt;len= 1;</span><br><span class="line"></span><br><span class="line">msgs[1]-&gt;addr= XXX_I2C_ADDR;</span><br><span class="line"></span><br><span class="line">msgs[1]-&gt;flags= 1;   /*read*/</span><br><span class="line"></span><br><span class="line">msgs[1]-&gt;buf[0]= 0;</span><br><span class="line"></span><br><span class="line">ret =ioctl(fd_X, I2C_RDWR, (unsigned long) &amp;i2c_data);  /*发送请求命令*/</span><br><span class="line"></span><br><span class="line">if(ret&lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">           return PTR_ERR(ret);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">           return msgs[1]-&gt;buf[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上讲述了一种比较常用的利用i2c-dev.c操作i2c设备的方法，这种方法可以说是在应用层完成了对具体i2c设备的驱动工作。</p>
<h2 id="1-7-Linux-I2C-驱动"><a href="#1-7-Linux-I2C-驱动" class="headerlink" title="1.7. Linux I2C 驱动"></a><strong>1.7.</strong> Linux I2C 驱动</h2><h3 id="1-7-1-适配器驱动"><a href="#1-7-1-适配器驱动" class="headerlink" title="1.7.1. 适配器驱动"></a>1.7.1. 适配器驱动</h3><h4 id="1-7-1-1-I2C适配器驱动的注册和注销"><a href="#1-7-1-1-I2C适配器驱动的注册和注销" class="headerlink" title="1.7.1.1. I2C适配器驱动的注册和注销"></a><strong>1.7.1.1.</strong> I2C适配器驱动的注册和注销</h4><p>注册通过在与I2C适配器所对应的platform_driver的probe()函数中完成</p>
<p>·初始化I2C 适配器所使用的硬件资源，如申请I/O 地址、中断号等。</p>
<p>·通过i2c_add_adapter()添加i2c_adapter 的数据结构，当然这个i2c_adapter 数据结构的成员已经被xxx 适配器的相应函数指针所初始化。</p>
<p>注销会在platform_driver的remove()函数中完成</p>
<p>·释放I2C 适配器所使用的硬件资源，如释放I/O 地址、中断号等。</p>
<p>·通过i2c_del_adapter()删除i2c_adapter 的数据结构。</p>
<h4 id="1-7-1-2-I2C总线的通信方法"><a href="#1-7-1-2-I2C总线的通信方法" class="headerlink" title="1.7.1.2. I2C总线的通信方法"></a><strong>1.7.1.2.</strong> I2C总线的通信方法</h4><p>通信方法主要是实现i2c_algorithm的functionality()函数和master_xfer()函数。</p>
<p>functionality()函数非常简单，用于返回algorithm 所支持的通信协议，如I2C_FUNC_I2C、I2C_FUNC_10BIT_ADDR、I2C_FUNC_SMBUS_READ_BYTE、I2C_FUNC_SMBUS_WRITE_BYTE 等。</p>
<p>master_xfer()函数在I2C 适配器上完成传递给它的i2c_msg 数组中的每个I2C 消息。</p>
<p>master_xfer()函数模板中的i2c_adapter_xxx_start()、i2c_adapter_xxx_setaddr()、i2c_adapter_xxx_wait_ack()、i2c_adapter_xxx_readbytes()、i2c_adapter_xxx_writebytes()和i2c_adapter_xxx_stop()函数用于实现底层硬件操作，主要是实现协议，由工程师根据芯片手册实现。</p>
<p>I2C 总线驱动会定义一个xxx_i2c 结构体，作为i2c_adapter 的algo_data（类似“私有数据”），其中包含I2C 消息数组指针、数组索引及I2C 适配器algorithm 访问控制用的自旋锁、等待队列等，而master_xfer()函数完成消息数组中消息的处理也可通过对xxx_i2c 结构体相关成员的访问来控制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct xxx_i2c &#123;</span><br><span class="line">    spinlock_t lock;</span><br><span class="line">    wait_queue_head_t wait;</span><br><span class="line">    struct i2c_msg *msg;</span><br><span class="line">    unsigned int msg_num;</span><br><span class="line">    unsigned int msg_idx;</span><br><span class="line">    unsigned int msg_ptr;</span><br><span class="line">    ...</span><br><span class="line">    struct i2c_adapter adap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-2-设备驱动"><a href="#1-7-2-设备驱动" class="headerlink" title="1.7.2. 设备驱动"></a>1.7.2. 设备驱动</h3><p>I2C 设备驱动要使用i2c_driver 和i2c_client 数据结构并填充i2c_driver 中的成员函数。i2c_client一般被包含在设备的私有信息结构体yyy_data 中，而i2c_driver 则适合被定义为全局变量并初始化。</p>
<p>I2C 设备驱动的模块加载函数通用的方法是i2c_add_driver()函数添加i2c_driver 的工作。而在模块卸载通过I2C核心的i2c_del_driver()函数删除i2c_driver。</p>
<p>I2C 设备上读写数据的时序和数据通常通过i2c_msg 数组组织，最后通过i2c_transfer()函数完成。</p>
<h2 id="1-8-添加i2c设备的方法"><a href="#1-8-添加i2c设备的方法" class="headerlink" title="1.8. 添加i2c设备的方法"></a><strong>1.8.</strong> 添加i2c设备的方法</h2><h3 id="1-8-1-根据I2C总线号来实例化设备（静态）"><a href="#1-8-1-根据I2C总线号来实例化设备（静态）" class="headerlink" title="1.8.1. 根据I2C总线号来实例化设备（静态）"></a>1.8.1. 根据I2C总线号来实例化设备（静态）</h3><p>适用于I2C作为系统总线的嵌入式设备。先声明，对I2C总线设备的定义是通过i2c_board_info来完成的，该结构体实例后，会被i2c_register_board_info()函数调用并挂到一个专门管理i2c_board_info结构的链表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static struct i2c_board_info __initdata at24cxx[] = &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		I2C_BOARD_INFO(“at24c01”,0x05),</span><br><span class="line">		//型号，地址</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __init init(void)</span><br><span class="line">&#123;</span><br><span class="line">	i2c_register_board_info(1,at24cxx,size);</span><br><span class="line">	//适配器几，设备信息地址，大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-2-显式地实例化设备（动态）"><a href="#1-8-2-显式地实例化设备（动态）" class="headerlink" title="1.8.2. 显式地实例化设备（动态）"></a>1.8.2. 显式地实例化设备（动态）</h3><p>适用于I2C总线作为一个大型设备的内部通信通道的情况。在定义这些子设备的时候，事先不能确定I2C总线号，通过填充结构i2c_board_info并调用i2c_new_device函数来实例化设备。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static struct i2c_board_info __initdata at24cxx[] = &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		I2C_BOARD_INFO(“at24c01”,0x05),</span><br><span class="line">		//型号，地址</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int at24c01_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_adapter *i2c_adap;</span><br><span class="line">	</span><br><span class="line">	i2c_adap = i2c_get_adapter(总线几);//调用core函数，获取总线</span><br><span class="line">	i2c_new_device(i2c_adap, &amp;at24cxx);//关联总线与设备</span><br><span class="line">	//适配器，设备信息地址</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-3-为特定的设备枚举I2C总线"><a href="#1-8-3-为特定的设备枚举I2C总线" class="headerlink" title="1.8.3. 为特定的设备枚举I2C总线"></a>1.8.3. 为特定的设备枚举I2C总线</h3><p>有时，没有 i2c device 的足够的信息，甚至不能调用 i2c_new_probed_device()，典型的事例是 PC 主板上的硬件监控芯片。有很多模型，这些模型可以有25个不同的地址。考虑到有大量的主板，要构建一个详尽的硬件列表几乎是不可能的，但，大部分这类芯片都有 manufacturer （制造商）和 device ID（设备 ID）寄存器，以供识别。</p>
<p>既然那样，I2C devices即不声明，也不明确实例化。相反的，一旦 i2c driver 加载，i2c-core将探测这些设备，如果找到，I2C device 会自动实例化。为了阻止这个机制中的一些错误情况，有一下 的一些限制：</p>
<p>i2c 的设备驱动必须实现 detect() 方法，用这个方法来读设备的专有寄存器。</p>
<p>只有可能含有支持设备，并同意 probe 的 bus 们才被用来 probe。</p>
<h3 id="1-8-4-在用户空间实例化设备"><a href="#1-8-4-在用户空间实例化设备" class="headerlink" title="1.8.4. 在用户空间实例化设备"></a>1.8.4. 在用户空间实例化设备</h3><p>内核要知道I2C设备挂到哪个I2C总线上以及I2C设备的地址。所以sysfs接口让用户空间提供这些信息各内核。提供了两个文件节点（new_device和delete_device），两个文件节点都是只写。</p>
<p>new_device有两个参数：I2C设备的名字（字符串）和I2C设备的地址。</p>
<p>delete_device只有一个参数：I2C设备地址。</p>
<p>示例:</p>
<p>创建设备：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#echo eeprom 0x16 &gt; /sys/bus/i2c/device/i2c-1/new_device</span><br></pre></td></tr></table></figure>

<p>删除设备：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#echo 0x16 &gt; /sys/bus/i2c/device/i2c-1/delete_device</span><br></pre></td></tr></table></figure>

<h2 id="1-9-内核空间使用"><a href="#1-9-内核空间使用" class="headerlink" title="1.9. 内核空间使用"></a><strong>1.9.</strong> 内核空间使用</h2><p>简单示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_board_info info;</span><br><span class="line">//填充i2c设备信息</span><br><span class="line">adapter = i2c_get_adapter(cc_si-&gt;i2c_bus_num);</span><br><span class="line">//获取i2c adapter</span><br><span class="line">client = i2c_new_device(adapter, &amp;info);</span><br><span class="line">//注册client</span><br><span class="line">struct i2c_msg msg</span><br><span class="line">//msg配置</span><br><span class="line">i2c_transfer(client-&gt;adapter, msg, 2);</span><br><span class="line">//进行传输</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-10-用户空间使用"><a href="#1-10-用户空间使用" class="headerlink" title="1.10. 用户空间使用"></a><strong>1.10.</strong> 用户空间使用</h2><p>简单示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">i2c_fd = open(i2c_name, O_RDWR | O_NONBLOCK);</span><br><span class="line">//打开i2c</span><br><span class="line">ioctl(i2c_fd, I2C_SLAVE, addr);</span><br><span class="line">//设置从机地址</span><br><span class="line">ioctl(g_i2c_test.i2c_fd, I2C_TIMEOUT, 2);</span><br><span class="line">//设置超时时间</span><br><span class="line">ioctl(g_i2c_test.i2c_fd, I2C_RETRIES, 2);</span><br><span class="line">//设置重复传输次数</span><br><span class="line">struct i2c_rdwr_ioctl_data i2c_data;</span><br><span class="line">struct i2c_msg msg = &#123;0&#125;;</span><br><span class="line">//msg配置</span><br><span class="line">ioctl(i2c_fd, I2C_RDWR, &amp;i2c_data);</span><br><span class="line">//进行传输</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://lskin.github.io/2021/07/27/I2C%E9%A9%B1%E5%8A%A8/" title="I2C驱动" target="_blank" rel="external">http://lskin.github.io/2021/07/27/I2C驱动/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://lskin.top" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg#%E5%A4%B4%E5%83%8F" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://lskin.top" target="_blank"><span class="text-dark">新坚</span><small class="ml-1x">开发者</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/07/27/V4L2%E9%A9%B1%E5%8A%A8/" title="V4L2驱动"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/lskin" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>